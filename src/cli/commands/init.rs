//! Initialize Guardy in a repository
//!
//! This command sets up Guardy configuration and installs git hooks.

use crate::cli::Output;
use crate::config::GuardyConfig;
use crate::utils::{get_current_dir, FileUtils};
use anyhow::Result;
use std::fs;
use std::path::Path;

/// Execute the init command
pub async fn execute(force: bool, output: &Output) -> Result<()> {
    let start_time = std::time::Instant::now();
    
    output.header("ðŸš€ Initializing Guardy");

    let current_dir = get_current_dir()?;
    
    // Step 1: Check git repository
    if output.is_verbose() {
        output.workflow_step(1, 4, "Checking git repository", "ðŸ”");
    }
    
    if !FileUtils::is_git_repository(&current_dir) {
        output.error("Not a git repository");
        if !force && !output.confirm("Initialize git repository first?") {
            output.info("Initialization cancelled");
            return Ok(());
        }
        
        // Initialize git repository
        let git_init = std::process::Command::new("git")
            .arg("init")
            .current_dir(&current_dir)
            .output()?;
            
        if git_init.status.success() {
            output.success("Git repository initialized");
        } else {
            output.error("Failed to initialize git repository");
            return Ok(());
        }
    }
    
    // Step 2: Initialize configuration
    if output.is_verbose() {
        output.workflow_step(2, 4, "Initializing configuration", "ðŸ”§");
    }
    initialize_config(&current_dir, force, output)?;
    
    // Install git hooks
    install_hooks(&current_dir, force, output)?;
    
    // Setup MCP server configuration
    setup_mcp_server(force, output)?;
    
    output.blank_line();
    output.success("Guardy initialization complete!");
    output.info("Next steps:");
    output.list_item("Review guardy.yml configuration");
    output.list_item("Run 'guardy status' to check installation");
    output.list_item("Make your first commit to test the hooks");
    
    // Show completion summary with timing
    let duration = start_time.elapsed();
    if output.is_verbose() {
        output.completion_summary("Guardy initialization", duration, true);
    }
    
    Ok(())
}

/// Initialize configuration file
fn initialize_config(current_dir: &Path, yes: bool, output: &Output) -> Result<()> {
    if output.is_verbose() {
        output.workflow_step(3, 4, "Setting up configuration", "âš™ï¸");
    }
    
    let config_path = current_dir.join("guardy.yml");
    
    if config_path.exists() {
        output.warning("Configuration file already exists");
        if !yes && !output.confirm("Do you want to overwrite it?") {
            output.info("Using existing configuration");
            return Ok(());
        }
    }
    
    // Create default configuration
    let config = GuardyConfig::default();
    config.save_to_file(&config_path)?;
    
    output.action_result("Configuration file", "created", true);
    if output.is_verbose() {
        output.key_value("Config file:", &config_path.display().to_string(), false);
    }
    
    Ok(())
}

/// Install git hooks
fn install_hooks(current_dir: &Path, yes: bool, output: &Output) -> Result<()> {
    if output.is_verbose() {
        output.workflow_step(4, 4, "Installing git hooks", "ðŸª");
    }
    
    let hooks_dir = current_dir.join(".git/hooks");
    
    if !hooks_dir.exists() {
        fs::create_dir_all(&hooks_dir)?;
    }
    
    let hooks = [("pre-commit", "Pre-commit hook"), ("commit-msg", "Commit message hook"), ("pre-push", "Pre-push hook")];
    let mut installed_count = 0;
    
    for (hook_name, description) in &hooks {
        let hook_path = hooks_dir.join(hook_name);
        
        if hook_path.exists() {
            output.warning(&format!("{} hook already exists", hook_name));
            if !yes && !output.confirm(&format!("Overwrite {} hook?", hook_name)) {
                output.info(&format!("Skipping {} hook", hook_name));
                continue;
            }
        }
        
        // Create hook script
        let hook_script = create_hook_script(hook_name)?;
        fs::write(&hook_path, hook_script)?;
        
        // Make executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&hook_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&hook_path, perms)?;
        }
        
        output.action_result(description, "installed", true);
        installed_count += 1;
    }
    
    if output.is_verbose() {
        output.summary_stats("Git hooks installed:", installed_count);
    }
    
    Ok(())
}

/// Create hook script content
fn create_hook_script(hook_name: &str) -> Result<String> {
    let script = format!(r#"#!/bin/sh
# Generated by Guardy
# This hook runs guardy to perform security checks and validations

# Check if guardy is available
if ! command -v guardy >/dev/null 2>&1; then
    echo "Error: guardy command not found"
    echo "Please install guardy or add it to your PATH"
    exit 1
fi

# Run guardy hook
exec guardy hooks run {}
"#, hook_name);
    
    Ok(script)
}

/// Setup MCP server configuration
fn setup_mcp_server(yes: bool, output: &Output) -> Result<()> {
    output.blank_line();
    output.step("MCP Server Setup");
    
    // TODO: Implement actual MCP server setup
    output.info("MCP server setup not yet implemented");
    output.info("This will:");
    output.list_item("Configure MCP server settings");
    output.list_item("Setup integration with Claude Desktop");
    output.list_item("Generate server configuration");
    
    if !yes {
        output.indent("Use --yes to skip interactive MCP setup");
    }
    
    Ok(())
}
