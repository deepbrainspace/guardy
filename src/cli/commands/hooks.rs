//! Git hooks command implementations
//!
//! Commands for managing git hooks installation and execution.

use crate::cli::HooksCommands;
use crate::cli::Output;
use crate::utils::{get_current_dir, is_git_repository};
use anyhow::Result;
use std::fs;

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

/// Execute hooks commands
pub async fn execute(cmd: HooksCommands, output: &Output) -> Result<()> {
    match cmd {
        HooksCommands::Install { force } => install(force, output).await,
        HooksCommands::Remove => remove(output).await,
        HooksCommands::List => list(output).await,
        HooksCommands::Run { hook } => run(hook, output).await,
    }
}

async fn install(force: bool, output: &Output) -> Result<()> {
    output.header("🔧 Installing Git Hooks");
    
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !is_git_repository(&current_dir) {
        output.error("Not a git repository");
        output.indent("Run 'git init' first");
        return Ok(());
    }
    
    let hooks_dir = current_dir.join(".git/hooks");
    
    if !hooks_dir.exists() {
        fs::create_dir_all(&hooks_dir)?;
        output.info("Created hooks directory");
    }
    
    let hooks = [
        ("pre-commit", "Security and formatting checks"),
        ("commit-msg", "Conventional commit validation"),
        ("pre-push", "Final validation before push"),
    ];
    
    output.info("Installing hooks:");
    
    for (hook_name, description) in &hooks {
        let hook_path = hooks_dir.join(hook_name);
        
        if hook_path.exists() && !force {
            output.warning(&format!("{} hook already exists (use --force to overwrite)", hook_name));
            continue;
        }
        
        // Create hook script
        let hook_script = create_hook_script(hook_name)?;
        fs::write(&hook_path, hook_script)?;
        
        // Make executable on Unix systems
        #[cfg(unix)]
        {
            let mut perms = fs::metadata(&hook_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&hook_path, perms)?;
        }
        
        output.success(&format!("{} - {}", hook_name, description));
    }
    
    output.blank_line();
    output.success("Git hooks installed successfully");
    output.info("Hooks will now run automatically on git operations");
    
    Ok(())
}

async fn remove(output: &Output) -> Result<()> {
    output.header("🗑️ Removing Git Hooks");
    
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !is_git_repository(&current_dir) {
        output.error("Not a git repository");
        return Ok(());
    }
    
    let hooks_dir = current_dir.join(".git/hooks");
    
    if !hooks_dir.exists() {
        output.info("No hooks directory found");
        return Ok(());
    }
    
    let hooks = ["pre-commit", "commit-msg", "pre-push"];
    let mut removed_count = 0;
    
    for hook_name in &hooks {
        let hook_path = hooks_dir.join(hook_name);
        
        if hook_path.exists() {
            // Check if it's a Guardy hook
            if let Ok(content) = fs::read_to_string(&hook_path) {
                if content.contains("Generated by Guardy") || content.contains("guardy hooks run") {
                    fs::remove_file(&hook_path)?;
                    output.success(&format!("{} hook removed", hook_name));
                    removed_count += 1;
                } else {
                    output.warning(&format!("{} hook exists but not managed by Guardy", hook_name));
                }
            } else {
                output.warning(&format!("{} hook exists but cannot be read", hook_name));
            }
        }
    }
    
    if removed_count > 0 {
        output.blank_line();
        output.success(&format!("{} Guardy hooks removed", removed_count));
    } else {
        output.info("No Guardy hooks found to remove");
    }
    
    Ok(())
}

async fn list(output: &Output) -> Result<()> {
    output.header("📋 Git Hooks Status");
    
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !is_git_repository(&current_dir) {
        output.error("Not a git repository");
        return Ok(());
    }
    
    let hooks_dir = current_dir.join(".git/hooks");
    
    let hooks = [
        ("pre-commit", "Security and formatting checks"),
        ("commit-msg", "Conventional commit validation"),
        ("pre-push", "Final validation before push"),
    ];
    
    output.info("Hook Status:");
    output.blank_line();
    
    for (hook_name, description) in &hooks {
        let hook_path = hooks_dir.join(hook_name);
        
        if hook_path.exists() {
            // Check if it's a Guardy hook
            if let Ok(content) = fs::read_to_string(&hook_path) {
                if content.contains("Generated by Guardy") || content.contains("guardy hooks run") {
                    output.success(&format!("{} - {} (Guardy managed)", hook_name, description));
                } else {
                    output.warning(&format!("{} - {} (Not managed by Guardy)", hook_name, description));
                }
            } else {
                output.warning(&format!("{} - {} (Cannot read hook file)", hook_name, description));
            }
        } else {
            output.info(&format!("{} - {} (Not installed)", hook_name, description));
        }
    }
    
    output.blank_line();
    output.info("Use 'guardy hooks install' to install missing hooks");
    output.info("Use 'guardy hooks install --force' to overwrite existing hooks");
    
    Ok(())
}

async fn run(hook: String, output: &Output) -> Result<()> {
    output.header(&format!("🏃 Running {} Hook", hook));
    
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !is_git_repository(&current_dir) {
        output.error("Not a git repository");
        return Ok(());
    }
    
    // TODO: Implement actual hook execution
    match hook.as_str() {
        "pre-commit" => {
            output.info("Running pre-commit hook...");
            output.info("This will perform:");
            output.list_item("Security scans for secrets");
            output.list_item("Code formatting checks");
            output.list_item("Linting validation");
            output.warning("Hook execution not yet implemented");
        }
        "commit-msg" => {
            output.info("Running commit-msg hook...");
            output.info("This will validate:");
            output.list_item("Conventional commit format");
            output.list_item("Commit message length");
            output.list_item("Breaking change detection");
            output.warning("Hook execution not yet implemented");
        }
        "pre-push" => {
            output.info("Running pre-push hook...");
            output.info("This will perform:");
            output.list_item("Final security validation");
            output.list_item("Branch protection checks");
            output.list_item("Test suite execution");
            output.warning("Hook execution not yet implemented");
        }
        _ => {
            output.error(&format!("Unknown hook: {}", hook));
            output.info("Available hooks: pre-commit, commit-msg, pre-push");
        }
    }
    
    Ok(())
}

/// Create hook script content
fn create_hook_script(hook_name: &str) -> Result<String> {
    let script = format!(r#"#!/bin/sh
# Generated by Guardy
# This hook runs guardy to perform security checks and validations

# Check if guardy is available
if ! command -v guardy >/dev/null 2>&1; then
    echo "Error: guardy command not found"
    echo "Please install guardy or add it to your PATH"
    exit 1
fi

# Run guardy hook
exec guardy hooks run {}
"#, hook_name);
    
    Ok(script)
}
