//! Git hooks command implementations
//!
//! Commands for managing git hooks installation and execution.

use crate::cli::HooksCommands;
use crate::cli::Output;
use crate::config::GuardyConfig;
use crate::hooks::{execute_hook, HookContext};
use crate::shared::{get_current_dir, FileUtils};
use anyhow::Result;
use std::fs;
use std::path::Path;
use std::process::Command;

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

/// Execute hooks commands
pub async fn execute(cmd: HooksCommands, force: bool, output: &Output) -> Result<()> {
    match cmd {
        HooksCommands::Install => install(force, output).await,
        HooksCommands::Remove => remove(output).await,
        HooksCommands::List => list(output).await,
        HooksCommands::Run { hook } => {
            let hooks_to_run = match hook {
                Some(hook_name) => vec![hook_name],
                None => vec!["pre-commit".to_string(), "commit-msg".to_string(), "pre-push".to_string(), "post-checkout".to_string()],
            };
            run(hooks_to_run, output).await
        },
    }
}

async fn install(force: bool, output: &Output) -> Result<()> {
    output.header("🔧 Installing Git Hooks");
    
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !FileUtils::is_git_repository(&current_dir) {
        output.error("Not a git repository");
        output.indent("Run 'git init' first");
        return Ok(());
    }
    
    let hooks_dir = current_dir.join(".git/hooks");
    
    if !hooks_dir.exists() {
        fs::create_dir_all(&hooks_dir)?;
        output.info("Created hooks directory");
    }
    
    let hooks = [
        ("pre-commit", "Security and formatting checks"),
        ("commit-msg", "Conventional commit validation"),
        ("pre-push", "Final validation before push"),
        ("post-checkout", "Dependency management automation"),
    ];
    
    output.info("Installing hooks:");
    
    for (hook_name, description) in &hooks {
        let hook_path = hooks_dir.join(hook_name);
        
        if hook_path.exists() && !force {
            output.warning(&format!("{} hook already exists (use --force to overwrite)", hook_name));
            continue;
        }
        
        // Create hook script
        let hook_script = create_hook_script(hook_name)?;
        fs::write(&hook_path, hook_script)?;
        
        // Make executable on Unix systems
        #[cfg(unix)]
        {
            let mut perms = fs::metadata(&hook_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&hook_path, perms)?;
        }
        
        output.success(&format!("{} - {}", hook_name, description));
    }
    
    output.blank_line();
    output.success("Git hooks installed successfully");
    output.info("Hooks will now run automatically on git operations");
    
    Ok(())
}

async fn remove(output: &Output) -> Result<()> {
    output.header("🗑️ Removing Git Hooks");
    
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !FileUtils::is_git_repository(&current_dir) {
        output.error("Not a git repository");
        return Ok(());
    }
    
    let hooks_dir = current_dir.join(".git/hooks");
    
    if !hooks_dir.exists() {
        output.info("No hooks directory found");
        return Ok(());
    }
    
    let hooks = ["pre-commit", "commit-msg", "pre-push", "post-checkout"];
    let mut removed_count = 0;
    
    for hook_name in &hooks {
        let hook_path = hooks_dir.join(hook_name);
        
        if hook_path.exists() {
            // Check if it's a Guardy hook
            if let Ok(content) = fs::read_to_string(&hook_path) {
                if content.contains("Generated by Guardy") || content.contains("guardy hooks run") {
                    fs::remove_file(&hook_path)?;
                    output.success(&format!("{} hook removed", hook_name));
                    removed_count += 1;
                } else {
                    output.warning(&format!("{} hook exists but not managed by Guardy", hook_name));
                }
            } else {
                output.warning(&format!("{} hook exists but cannot be read", hook_name));
            }
        }
    }
    
    if removed_count > 0 {
        output.blank_line();
        output.success(&format!("{} Guardy hooks removed", removed_count));
    } else {
        output.info("No Guardy hooks found to remove");
    }
    
    Ok(())
}

async fn list(output: &Output) -> Result<()> {
    output.header("📋 Git Hooks Status");
    
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !FileUtils::is_git_repository(&current_dir) {
        output.error("Not a git repository");
        return Ok(());
    }
    
    let hooks_dir = current_dir.join(".git/hooks");
    
    let hooks = [
        ("pre-commit", "Security and formatting checks"),
        ("commit-msg", "Conventional commit validation"),
        ("pre-push", "Final validation before push"),
        ("post-checkout", "Dependency management automation"),
    ];
    
    output.info("Hook Status:");
    output.blank_line();
    
    for (hook_name, description) in &hooks {
        let hook_path = hooks_dir.join(hook_name);
        
        if hook_path.exists() {
            // Check if it's a Guardy hook
            if let Ok(content) = fs::read_to_string(&hook_path) {
                if content.contains("Generated by Guardy") || content.contains("guardy hooks run") {
                    output.success(&format!("{} - {} (Guardy managed)", hook_name, description));
                } else {
                    output.warning(&format!("{} - {} (Not managed by Guardy)", hook_name, description));
                }
            } else {
                output.warning(&format!("{} - {} (Cannot read hook file)", hook_name, description));
            }
        } else {
            output.info(&format!("{} - {} (Not installed)", hook_name, description));
        }
    }
    
    output.blank_line();
    output.info("Use 'guardy hooks install' to install missing hooks");
    output.info("Use 'guardy hooks install --force' to overwrite existing hooks");
    
    Ok(())
}

async fn run(hooks: Vec<String>, output: &Output) -> Result<()> {
    let current_dir = get_current_dir()?;
    
    // Check if we're in a git repository
    if !FileUtils::is_git_repository(&current_dir) {
        output.error("Not a git repository");
        return Ok(());
    }
    
    let is_single_hook = hooks.len() == 1;
    let mut failed_hooks = Vec::new();
    
    // Show header only for multiple hooks
    if !is_single_hook {
        output.header("🔧 Running All Git Hooks");
    }
    
    for hook in &hooks {
        let start_time = std::time::Instant::now();
        
        // Show section header for all hooks
        if !is_single_hook {
            output.section_header(&format!("Running {} hook", hook));
        }
        
        // Execute hook using the hooks module
        let success = match execute_hook_via_module(hook, &current_dir, output).await {
            Ok(_) => true,
            Err(e) => {
                output.error(&format!("Hook '{}' failed: {}", hook, e));
                false
            }
        };
        
        let duration = start_time.elapsed();
        
        if success {
            output.completion_summary(&format!("{} hook", hook), duration, true);
        } else {
            failed_hooks.push(hook.clone());
            output.completion_summary(&format!("{} hook", hook), duration, false);
        }
        
        // Add blank line between hooks (except for last one)
        if !is_single_hook && hook != &hooks[hooks.len() - 1] {
            output.blank_line();
        }
    }
    
    // Show summary for multiple hooks or handle single hook failure
    if !is_single_hook {
        output.blank_line();
        if failed_hooks.is_empty() {
            output.success("All hooks completed successfully");
        } else {
            output.error(&format!("Failed hooks: {}", failed_hooks.join(", ")));
            std::process::exit(1);
        }
    } else if !failed_hooks.is_empty() {
        std::process::exit(1);
    }
    
    Ok(())
}

/// Create hook script content
fn create_hook_script(hook_name: &str) -> Result<String> {
    let script = format!(r#"#!/bin/sh
# Generated by Guardy
# This hook runs guardy to perform security checks and validations

# Check if guardy is available
if ! command -v guardy >/dev/null 2>&1; then
    echo "Error: guardy command not found"
    echo "Please install guardy or add it to your PATH"
    exit 1
fi

# Run guardy hook
exec guardy hooks run {}
"#, hook_name);
    
    Ok(script)
}

/// Execute hook via the hooks module
async fn execute_hook_via_module(hook_name: &str, current_dir: &std::path::Path) -> Result<()> {
    // Load configuration
    let config = GuardyConfig::load_from_file(&current_dir.join("guardy.yml"))
        .unwrap_or_default();
    
    // Create hook context
    let context = HookContext::new(
        hook_name.to_string(),
        config,
        vec![] // No additional args for now
    );
    
    // Execute the hook
    execute_hook(context).await
}





/// Run dependency installation command
fn run_dependency_install(package_manager: &str, args: &[&str], current_dir: &Path, output: &Output) -> Result<bool> {
    let mut cmd = Command::new(package_manager);
    cmd.args(args)
        .current_dir(current_dir);
    
    if output.is_verbose() {
        output.info(&format!("Running: {} {}", package_manager, args.join(" ")));
    }
    
    let result = cmd.output()?;
    
    if output.is_verbose() {
        if !result.stdout.is_empty() {
            let stdout = String::from_utf8_lossy(&result.stdout);
            output.info(&format!("Output: {}", stdout));
        }
        if !result.stderr.is_empty() {
            let stderr = String::from_utf8_lossy(&result.stderr);
            output.info(&format!("Stderr: {}", stderr));
        }
    }
    
    Ok(result.status.success())
}

/// Get list of staged files
fn get_staged_files(current_dir: &Path) -> Result<Vec<String>> {
    let output = Command::new("git")
        .args(["diff", "--cached", "--name-only"])
        .current_dir(current_dir)
        .output()?;
    
    if !output.status.success() {
        return Ok(vec![]);
    }
    
    let files = String::from_utf8(output.stdout)?
        .lines()
        .map(|line| line.trim().to_string())
        .filter(|line| !line.is_empty())
        .collect();
    
    Ok(files)
}

/// Get current git branch
fn get_current_branch(current_dir: &Path) -> Result<String> {
    let output = Command::new("git")
        .args(["branch", "--show-current"])
        .current_dir(current_dir)
        .output()?;
    
    if !output.status.success() {
        anyhow::bail!("Failed to get current branch");
    }
    
    let branch = String::from_utf8(output.stdout)?
        .trim()
        .to_string();
    
    Ok(branch)
}

/// Check if commit message follows conventional commit format
fn is_conventional_commit(message: &str) -> bool {
    // Basic conventional commit pattern: type(scope): description
    // or type: description
    let patterns = [
        r"^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .+",
        r"^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)!(\(.+\))?: .+", // breaking change
    ];
    
    for pattern in &patterns {
        if regex::Regex::new(pattern).unwrap().is_match(message) {
            return true;
        }
    }
    
    false
}

/// Find files that match formatter patterns
fn find_matching_files(files: &[String], patterns: &[String]) -> Vec<String> {
    let mut matching_files = Vec::new();
    
    for file in files {
        for pattern in patterns {
            if glob_match(pattern, file) {
                matching_files.push(file.clone());
                break;
            }
        }
    }
    
    matching_files
}

/// Simple glob matching for file patterns
fn glob_match(pattern: &str, file: &str) -> bool {
    // Convert simple glob patterns to regex
    let mut regex_pattern = pattern.to_string();
    
    // Replace ** with .* (matches anything including path separators)
    regex_pattern = regex_pattern.replace("**", "DOUBLE_STAR");
    // Replace * with [^/]* (matches anything except path separators)
    regex_pattern = regex_pattern.replace("*", "[^/]*");
    // Replace the placeholder back with .*
    regex_pattern = regex_pattern.replace("DOUBLE_STAR", ".*");
    // Replace ? with [^/] (matches single character except path separator)
    regex_pattern = regex_pattern.replace("?", "[^/]");
    
    if let Ok(regex) = regex::Regex::new(&format!("^{}$", regex_pattern)) {
        regex.is_match(file)
    } else {
        false
    }
}

/// Validate lockfiles to ensure dependencies are synchronized
async fn validate_lockfiles(current_dir: &Path, output: &Output) -> Result<bool> {
    // Check if configuration enables lockfile validation
    let config_result = GuardyConfig::load_from_file(&current_dir.join("guardy.yml"));
    let enable_lockfile_validation = if let Ok(_config) = &config_result {
        // TODO: Add configuration flag support when config schema is updated
        // For now, default to enabled
        true
    } else {
        // Default to enabled if no config found
        true
    };
    
    if !enable_lockfile_validation {
        output.info("Lockfile validation is disabled");
        return Ok(true);
    }
    
    // Detect package manager and validate appropriate lockfiles
    if current_dir.join("pnpm-lock.yaml").exists() {
        validate_pnpm_lockfile(current_dir, output).await
    } else if current_dir.join("package-lock.json").exists() {
        validate_npm_lockfile(current_dir, output).await
    } else if current_dir.join("yarn.lock").exists() {
        validate_yarn_lockfile(current_dir, output).await
    } else if current_dir.join("Cargo.lock").exists() {
        validate_cargo_lockfile(current_dir, output).await
    } else {
        output.info("No lockfile detected, skipping validation");
        Ok(true)
    }
}

/// Validate pnpm lockfile synchronization
async fn validate_pnpm_lockfile(current_dir: &Path, output: &Output) -> Result<bool> {
    output.info("Validating pnpm lockfile synchronization...");
    
    // Run pnpm install --frozen-lockfile to test if lockfile is in sync
    let result = Command::new("pnpm")
        .args(["install", "--frozen-lockfile"])
        .current_dir(current_dir)
        .output();
    
    match result {
        Ok(output_result) => {
            if output_result.status.success() {
                output.success("pnpm lockfile is synchronized");
                Ok(true)
            } else {
                let stderr = String::from_utf8_lossy(&output_result.stderr);
                output.error("pnpm lockfile is out of sync");
                if output.is_verbose() {
                    output.indent(&format!("Error: {}", stderr));
                }
                output.indent("Run 'pnpm install' to synchronize dependencies");
                Ok(false)
            }
        }
        Err(e) => {
            output.warning("pnpm command not found or failed to execute");
            if output.is_verbose() {
                output.indent(&format!("Error: {}", e));
            }
            // Don't fail validation if pnpm is not available
            Ok(true)
        }
    }
}

/// Validate npm lockfile synchronization
async fn validate_npm_lockfile(current_dir: &Path, output: &Output) -> Result<bool> {
    output.info("Validating npm lockfile synchronization...");
    
    // Run npm ci to test if lockfile is in sync (npm ci fails if package.json and package-lock.json are out of sync)
    let result = Command::new("npm")
        .args(["ci", "--dry-run"])
        .current_dir(current_dir)
        .output();
    
    match result {
        Ok(output_result) => {
            if output_result.status.success() {
                output.success("npm lockfile is synchronized");
                Ok(true)
            } else {
                let stderr = String::from_utf8_lossy(&output_result.stderr);
                output.error("npm lockfile is out of sync");
                if output.is_verbose() {
                    output.indent(&format!("Error: {}", stderr));
                }
                output.indent("Run 'npm install' to synchronize dependencies");
                Ok(false)
            }
        }
        Err(e) => {
            output.warning("npm command not found or failed to execute");
            if output.is_verbose() {
                output.indent(&format!("Error: {}", e));
            }
            // Don't fail validation if npm is not available
            Ok(true)
        }
    }
}

/// Validate yarn lockfile synchronization
async fn validate_yarn_lockfile(current_dir: &Path, output: &Output) -> Result<bool> {
    output.info("Validating yarn lockfile synchronization...");
    
    // Run yarn install --frozen-lockfile to test if lockfile is in sync
    let result = Command::new("yarn")
        .args(["install", "--frozen-lockfile"])
        .current_dir(current_dir)
        .output();
    
    match result {
        Ok(output_result) => {
            if output_result.status.success() {
                output.success("yarn lockfile is synchronized");
                Ok(true)
            } else {
                let stderr = String::from_utf8_lossy(&output_result.stderr);
                output.error("yarn lockfile is out of sync");
                if output.is_verbose() {
                    output.indent(&format!("Error: {}", stderr));
                }
                output.indent("Run 'yarn install' to synchronize dependencies");
                Ok(false)
            }
        }
        Err(e) => {
            output.warning("yarn command not found or failed to execute");
            if output.is_verbose() {
                output.indent(&format!("Error: {}", e));
            }
            // Don't fail validation if yarn is not available
            Ok(true)
        }
    }
}

/// Validate Cargo lockfile synchronization
async fn validate_cargo_lockfile(current_dir: &Path, output: &Output) -> Result<bool> {
    output.info("Validating Cargo lockfile synchronization...");
    
    // Run cargo check --locked to test if Cargo.lock is in sync with Cargo.toml
    let result = Command::new("cargo")
        .args(["check", "--locked"])
        .current_dir(current_dir)
        .output();
    
    match result {
        Ok(output_result) => {
            if output_result.status.success() {
                output.success("Cargo lockfile is synchronized");
                Ok(true)
            } else {
                let stderr = String::from_utf8_lossy(&output_result.stderr);
                output.error("Cargo lockfile is out of sync");
                if output.is_verbose() {
                    output.indent(&format!("Error: {}", stderr));
                }
                output.indent("Run 'cargo update' to synchronize dependencies");
                Ok(false)
            }
        }
        Err(e) => {
            output.warning("cargo command not found or failed to execute");
            if output.is_verbose() {
                output.indent(&format!("Error: {}", e));
            }
            // Don't fail validation if cargo is not available
            Ok(true)
        }
    }
}

/// Run formatter in check mode to see if files need formatting
fn run_formatter_check(command: &str, files: &[String], current_dir: &Path, output: &Output) -> Result<bool> {
    // Different formatters have different check modes
    let check_command = if command.contains("cargo fmt") {
        "cargo fmt -- --check".to_string()
    } else if command.contains("prettier") {
        format!("{} --check", command)
    } else if command.contains("black") {
        format!("{} --check", command)
    } else if command.contains("ruff format") {
        format!("{} --check", command)
    } else if command.contains("gofmt") {
        format!("{} -d", command)
    } else {
        // For other formatters, try common check patterns
        format!("{} --check", command)
    };
    
    // Run the check command
    let mut cmd = Command::new("sh");
    cmd.arg("-c")
        .arg(&check_command)
        .current_dir(current_dir);
    
    // Add files as arguments if the formatter supports it
    if !command.contains("cargo fmt") {
        for file in files {
            cmd.arg(file);
        }
    }
    
    let result = cmd.output()?;
    
    if output.is_verbose() {
        if !result.stdout.is_empty() {
            let stdout = String::from_utf8_lossy(&result.stdout);
            output.info(&format!("Formatter output: {}", stdout));
        }
        if !result.stderr.is_empty() {
            let stderr = String::from_utf8_lossy(&result.stderr);
            output.info(&format!("Formatter stderr: {}", stderr));
        }
    }
    
    // Non-zero exit code usually means formatting is needed
    Ok(!result.status.success())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;
    use crate::config::{GuardyConfig, SecurityConfig, HooksConfig, McpConfig, ToolsConfig, FormatterConfig, InstallConfig};

    fn create_test_config() -> GuardyConfig {
        GuardyConfig {
            security: SecurityConfig::default(),
            hooks: HooksConfig::default(),
            mcp: McpConfig::default(),
            tools: ToolsConfig {
                auto_detect: true,
                auto_install: false,
                formatters: vec![
                    FormatterConfig {
                        name: "rustfmt".to_string(),
                        command: "cargo fmt".to_string(),
                        patterns: vec!["**/*.rs".to_string()],
                        check_command: Some("rustfmt --version".to_string()),
                        install: Some(InstallConfig {
                            cargo: Some("rustup component add rustfmt".to_string()),
                            npm: None,
                            brew: None,
                            apt: None,
                            manual: "Install Rust toolchain: https://rustup.rs/".to_string(),
                        }),
                    },
                ],
                linters: vec![],
            },
        }
    }

    fn create_test_repository() -> TempDir {
        let temp_dir = TempDir::new().unwrap();
        
        // Initialize git repository
        std::process::Command::new("git")
            .args(["init"])
            .current_dir(temp_dir.path())
            .output()
            .unwrap();
        
        // Configure git user (required for commits)
        std::process::Command::new("git")
            .args(["config", "user.name", "Test User"])
            .current_dir(temp_dir.path())
            .output()
            .unwrap();
        
        std::process::Command::new("git")
            .args(["config", "user.email", "test@example.com"])
            .current_dir(temp_dir.path())
            .output()
            .unwrap();
        
        temp_dir
    }

    #[test]
    fn test_glob_match() {
        assert!(glob_match("**/*.rs", "src/main.rs"));
        assert!(glob_match("**/*.rs", "lib/utils/mod.rs"));
        assert!(glob_match("*.js", "index.js"));
        assert!(!glob_match("*.js", "src/main.rs"));
        assert!(!glob_match("**/*.rs", "Cargo.toml"));
    }

    #[test]
    fn test_find_matching_files() {
        let files = vec![
            "src/main.rs".to_string(),
            "src/lib.rs".to_string(),
            "index.js".to_string(),
            "package.json".to_string(),
        ];
        
        let rust_patterns = vec!["**/*.rs".to_string()];
        let matching_rust = find_matching_files(&files, &rust_patterns);
        assert_eq!(matching_rust.len(), 2);
        assert!(matching_rust.contains(&"src/main.rs".to_string()));
        assert!(matching_rust.contains(&"src/lib.rs".to_string()));
    }

    #[test]
    fn test_is_conventional_commit() {
        // Valid conventional commits
        assert!(is_conventional_commit("feat: add new feature"));
        assert!(is_conventional_commit("fix: resolve bug"));
        assert!(is_conventional_commit("feat(auth): add login functionality"));
        assert!(is_conventional_commit("fix(api): handle error cases"));
        assert!(is_conventional_commit("chore: update dependencies"));
        assert!(is_conventional_commit("feat!: breaking change"));
        assert!(is_conventional_commit("fix!(api): breaking fix"));
        
        // Invalid conventional commits
        assert!(!is_conventional_commit("add new feature"));
        assert!(!is_conventional_commit("bug fix"));
        assert!(!is_conventional_commit("feat:"));
        assert!(!is_conventional_commit("invalid: message"));
        assert!(!is_conventional_commit(""));
    }

    #[tokio::test]
    async fn test_pre_commit_hook_with_formatters() {
        let temp_dir = create_test_repository();
        let config = create_test_config();
        
        // Create guardy.yml in temp directory
        let config_path = temp_dir.path().join("guardy.yml");
        config.save_to_file(&config_path).unwrap();
        
        // Create a poorly formatted Rust file
        let src_dir = temp_dir.path().join("src");
        fs::create_dir_all(&src_dir).unwrap();
        let main_rs = src_dir.join("main.rs");
        fs::write(&main_rs, r#"fn main(){
let  x   =    5;
    println!("Hello, world! The value is: {}", x);
let mut y=10;
y+=1;
println!("Y is: {}",y);
}"#).unwrap();
        
        // Create Cargo.toml to make it a valid Rust project
        let cargo_toml = temp_dir.path().join("Cargo.toml");
        fs::write(&cargo_toml, r#"[package]
name = "test-project"
version = "0.1.0"
edition = "2021"

[dependencies]"#).unwrap();
        
        // Stage the files
        std::process::Command::new("git")
            .args(["add", "."])
            .current_dir(temp_dir.path())
            .output()
            .unwrap();
        
        // Test get_staged_files function
        let staged_files = get_staged_files(temp_dir.path()).unwrap();
        assert!(!staged_files.is_empty());
        assert!(staged_files.contains(&"src/main.rs".to_string()));
        
        // Test the pre-commit hook execution
        let output = Output::new(true, false); // verbose=true, quiet=false
        
        // This should detect formatting issues if rustfmt is available
        let result = execute_pre_commit_hook(temp_dir.path(), &output).await;
        
        match result {
            Ok(success) => {
                // If rustfmt is available, it should detect formatting issues
                if Command::new("rustfmt").arg("--version").output().is_ok() {
                    // We expect this to fail due to formatting issues
                    println!("Pre-commit hook result: {}", success);
                } else {
                    println!("rustfmt not available, skipping formatter test");
                }
            }
            Err(e) => {
                println!("Pre-commit hook error: {}", e);
            }
        }
    }
}
