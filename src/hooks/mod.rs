//! Git hooks implementation for Guardy
//!
//! This module provides the actual git hook implementations that will be
//! installed and executed by Guardy.

use crate::config::GuardyConfig;
use anyhow::Result;

pub mod commit_msg;
pub mod post_checkout;
pub mod pre_commit;
pub mod pre_push;

/// Generate hook script content
/// TODO: Remove #[allow(dead_code)] when hook commands are implemented in Phase 1.5
#[allow(dead_code)]
pub fn generate_hook_script(hook_name: &str, _config: &GuardyConfig) -> Result<String> {
    let guardy_binary = std::env::current_exe()?.to_string_lossy().to_string();

    let script = format!(
        r#"#!/bin/sh
# Generated by Guardy - Intelligent Git Workflows for Modern Developers
# Do not edit this file manually

set -e

# Run the specific hook through Guardy
exec "{}" hooks run "{}"
"#,
        guardy_binary, hook_name
    );

    Ok(script)
}

/// Hook execution context
/// TODO: Remove #[allow(dead_code)] when hook commands are implemented in Phase 1.5
#[allow(dead_code)]
pub struct HookContext {
    /// Hook name
    pub hook_name: String,

    /// Configuration
    pub config: GuardyConfig,

    /// Command line arguments passed to the hook
    pub args: Vec<String>,
}

#[allow(dead_code)]
impl HookContext {
    /// Create a new hook context
    pub fn new(hook_name: String, config: GuardyConfig, args: Vec<String>) -> Self {
        Self {
            hook_name,
            config,
            args,
        }
    }
}

/// Execute a hook by name
pub async fn execute_hook(context: HookContext) -> Result<()> {
    match context.hook_name.as_str() {
        "pre-commit" => pre_commit::execute(context).await,
        "commit-msg" => commit_msg::execute(context).await,
        "pre-push" => pre_push::execute(context).await,
        "post-checkout" => post_checkout::execute(context).await,
        _ => anyhow::bail!("Unknown hook: {}", context.hook_name),
    }
}
