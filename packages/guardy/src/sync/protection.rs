use anyhow::{anyhow, Result};
use std::path::{Path, PathBuf};
use std::fs;
use std::collections::HashSet;

use super::{ProtectionConfig, SyncRepo};

/// Manages protection of synced files
pub struct ProtectionManager {
    config: ProtectionConfig,
    protected_files: HashSet<PathBuf>,
    protection_file: PathBuf,
}

impl ProtectionManager {
    pub fn new(config: ProtectionConfig) -> Result<Self> {
        let protection_file = PathBuf::from(".guardy/protected_files.txt");
        
        // Load existing protected files list
        let protected_files = if protection_file.exists() {
            Self::load_protected_files(&protection_file)?
        } else {
            HashSet::new()
        };

        Ok(Self {
            config,
            protected_files,
            protection_file,
        })
    }

    /// Check if a file is protected
    pub fn is_protected(&self, file_path: &Path) -> bool {
        if !self.config.block_modifications {
            return false;
        }

        // Normalize the path for comparison
        let normalized = file_path.canonicalize().unwrap_or_else(|_| file_path.to_path_buf());
        self.protected_files.contains(&normalized)
    }

    /// Protect files that were synced from a repository
    pub fn protect_synced_files(&mut self, repo: &SyncRepo, synced_files: Vec<PathBuf>) -> Result<()> {
        if !repo.protected || !self.config.auto_protect_synced {
            return Ok(());
        }

        for file in synced_files {
            // Normalize and add to protected set
            if let Ok(normalized) = file.canonicalize() {
                self.protected_files.insert(normalized);
            } else {
                self.protected_files.insert(file);
            }
        }

        // Save updated protection list
        self.save_protected_files()?;

        Ok(())
    }

    /// Remove protection from files
    pub fn unprotect_files(&mut self, files: Vec<PathBuf>) -> Result<()> {
        for file in files {
            // Try to normalize the path for removal
            if let Ok(normalized) = file.canonicalize() {
                self.protected_files.remove(&normalized);
            }
            // Also try to remove the non-normalized version
            self.protected_files.remove(&file);
        }

        // Save updated protection list
        self.save_protected_files()?;

        Ok(())
    }

    /// Clear all protections
    pub fn clear_all_protections(&mut self) -> Result<()> {
        self.protected_files.clear();
        self.save_protected_files()?;
        Ok(())
    }

    /// Get list of all protected files
    pub fn list_protected_files(&self) -> Vec<PathBuf> {
        self.protected_files.iter().cloned().collect()
    }

    /// Check if modifications to protected files should be blocked
    pub fn should_block_modifications(&self) -> bool {
        self.config.block_modifications
    }

    /// Validate that no protected files will be modified by an operation
    pub fn validate_modifications(&self, files_to_modify: &[PathBuf]) -> Result<()> {
        if !self.config.block_modifications {
            return Ok(());
        }

        let mut protected_violations = Vec::new();

        for file in files_to_modify {
            if self.is_protected(file) {
                protected_violations.push(file.clone());
            }
        }

        if !protected_violations.is_empty() {
            let files_list = protected_violations
                .iter()
                .map(|p| format!("  - {}", p.display()))
                .collect::<Vec<_>>()
                .join("\n");
                
            return Err(anyhow!(
                "Cannot modify protected files:\n{}\n\nThese files are protected by sync configuration. \
                 To modify them, either:\n  1. Update them in the source repository\n  \
                 2. Disable protection with 'guardy sync unprotect'\n  \
                 3. Set block_modifications=false in configuration",
                files_list
            ));
        }

        Ok(())
    }

    /// Load protected files list from disk
    fn load_protected_files(path: &Path) -> Result<HashSet<PathBuf>> {
        let content = fs::read_to_string(path)?;
        let mut files = HashSet::new();

        for line in content.lines() {
            let line = line.trim();
            if !line.is_empty() && !line.starts_with('#') {
                files.insert(PathBuf::from(line));
            }
        }

        Ok(files)
    }

    /// Save protected files list to disk
    fn save_protected_files(&self) -> Result<()> {
        // Ensure directory exists
        if let Some(parent) = self.protection_file.parent() {
            fs::create_dir_all(parent)?;
        }

        let mut content = String::new();
        content.push_str("# Protected files managed by Guardy sync\n");
        content.push_str("# Do not edit this file manually\n\n");

        let mut sorted_files: Vec<_> = self.protected_files.iter().collect();
        sorted_files.sort();

        for file in sorted_files {
            content.push_str(&format!("{}\n", file.display()));
        }

        fs::write(&self.protection_file, content)?;

        Ok(())
    }

    /// Create a backup of files before they are overwritten by sync
    pub fn backup_before_sync(&self, files_to_overwrite: &[PathBuf]) -> Result<Vec<PathBuf>> {
        if files_to_overwrite.is_empty() {
            return Ok(Vec::new());
        }

        let backup_dir = PathBuf::from(".guardy/backups");
        // Use system time for timestamp
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        let backup_subdir = backup_dir.join(format!("sync_{timestamp}"));
        
        fs::create_dir_all(&backup_subdir)?;

        let mut backed_up_files = Vec::new();

        for file in files_to_overwrite {
            if !file.exists() {
                continue;
            }

            // Create relative path for backup
            let backup_path = if file.is_absolute() {
                backup_subdir.join(file.strip_prefix("/").unwrap_or(file))
            } else {
                backup_subdir.join(file)
            };

            // Ensure backup directory structure exists
            if let Some(parent) = backup_path.parent() {
                fs::create_dir_all(parent)?;
            }

            // Copy file to backup location
            fs::copy(file, &backup_path)?;
            backed_up_files.push(backup_path);
        }

        if !backed_up_files.is_empty() {
            tracing::info!("Backed up {} files to {}", 
                         backed_up_files.len(), backup_subdir.display());
        }

        Ok(backed_up_files)
    }

    /// Restore files from backup
    pub fn restore_from_backup(&self, backup_path: &Path) -> Result<()> {
        if !backup_path.exists() {
            return Err(anyhow!("Backup path does not exist: {}", backup_path.display()));
        }

        // Walk through backup directory and restore files
        restore_directory_recursive(backup_path, Path::new("."))?;

        Ok(())
    }
}

/// Free function to recursively restore directory contents
fn restore_directory_recursive(source: &Path, base_dest: &Path) -> Result<()> {
    for entry in fs::read_dir(source)? {
        let entry = entry?;
        let entry_path = entry.path();
        
        // Calculate relative path from backup root
        let rel_path = entry_path.strip_prefix(source)
            .unwrap_or(&entry_path);
        let dest_path = base_dest.join(rel_path);

        if entry_path.is_dir() {
            restore_directory_recursive(&entry_path, base_dest)?;
        } else {
            // Ensure destination directory exists
            if let Some(parent) = dest_path.parent() {
                fs::create_dir_all(parent)?;
            }

            // Restore the file
            fs::copy(&entry_path, &dest_path)?;
            tracing::debug!("Restored: {} -> {}", entry_path.display(), dest_path.display());
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_protection_manager_new() {
        let config = ProtectionConfig::default();
        let manager = ProtectionManager::new(config).unwrap();
        assert!(manager.protected_files.is_empty());
    }

    #[test]
    fn test_protect_and_check_files() {
        let config = ProtectionConfig::default();
        let mut manager = ProtectionManager::new(config).unwrap();
        
        let files = vec![
            PathBuf::from("test1.txt"),
            PathBuf::from("test2.txt"),
        ];
        
        let repo = SyncRepo {
            name: "test".to_string(),
            repo: "test-repo".to_string(),
            version: "v1.0.0".to_string(),
            source_path: ".".to_string(),
            dest_path: ".".to_string(),
            include: vec![],
            exclude: vec![],
            protected: true,
        };
        
        manager.protect_synced_files(&repo, files.clone()).unwrap();
        
        // Check if files are protected
        assert!(manager.is_protected(&PathBuf::from("test1.txt")));
        assert!(manager.is_protected(&PathBuf::from("test2.txt")));
    }

    #[test]
    fn test_unprotect_files() {
        let config = ProtectionConfig::default();
        let mut manager = ProtectionManager::new(config).unwrap();
        
        // Add some protected files
        manager.protected_files.insert(PathBuf::from("test1.txt"));
        manager.protected_files.insert(PathBuf::from("test2.txt"));
        
        // Unprotect one file
        manager.unprotect_files(vec![PathBuf::from("test1.txt")]).unwrap();
        
        assert!(!manager.is_protected(&PathBuf::from("test1.txt")));
        assert!(manager.is_protected(&PathBuf::from("test2.txt")));
    }

    #[test]
    fn test_validate_modifications() {
        let config = ProtectionConfig::default();
        let mut manager = ProtectionManager::new(config).unwrap();
        
        // Add protected file
        manager.protected_files.insert(PathBuf::from("protected.txt"));
        
        // Should fail for protected file
        let result = manager.validate_modifications(&[PathBuf::from("protected.txt")]);
        assert!(result.is_err());
        
        // Should succeed for non-protected file
        let result = manager.validate_modifications(&[PathBuf::from("unprotected.txt")]);
        assert!(result.is_ok());
    }

    #[test]
    fn test_backup_before_sync() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.txt");
        fs::write(&test_file, "test content").unwrap();
        
        let config = ProtectionConfig::default();
        let manager = ProtectionManager::new(config).unwrap();
        
        let backed_up = manager.backup_before_sync(&[test_file.clone()]).unwrap();
        assert!(!backed_up.is_empty());
        
        // Check backup file exists
        let backup_file = &backed_up[0];
        assert!(backup_file.exists());
        
        // Check content matches
        let backup_content = fs::read_to_string(backup_file).unwrap();
        assert_eq!(backup_content, "test content");
    }
}