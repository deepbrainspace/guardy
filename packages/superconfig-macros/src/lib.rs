//! # SuperConfig Procedural Macros
//! 
//! This crate provides procedural macros for the [`superconfig`] library that automatically
//! generate Rust configuration structs from existing configuration files using [Typify].
//! 
//! ## Key Features
//! 
//! - ðŸ—ï¸ **Zero boilerplate**: No manual struct definitions required
//! - ðŸ” **Automatic type inference**: Generates structs from JSON/YAML files using Typify
//! - ðŸš€ **LazyLock integration**: Creates static instances for zero-copy access
//! - ðŸ“ **Flexible file discovery**: Searches multiple paths for config files
//! - âš¡ **Compile-time validation**: Ensures config file exists and is valid
//! 
//! ## Usage
//! 
//! The primary macro is [`config!`] which takes a config name and generates a complete
//! configuration struct hierarchy with a static LazyLock instance.
//! 
//! ```rust
//! use fast_config::config;
//! 
//! // Auto-generates MyAppConfig struct from myapp.json/yaml
//! config!("myapp" => MyAppConfig);
//! 
//! // Zero-copy access throughout your application
//! let config = MyAppConfig::global();
//! println!("Server port: {}", config.server.port);
//! ```
//! 
//! ## Generated Code
//! 
//! For a config file like `myapp.json`:
//! 
//! ```json
//! {
//!   "server": {
//!     "port": 8080,
//!     "host": "localhost"
//!   },
//!   "database": {
//!     "url": "postgres://localhost/myapp",
//!     "pool_size": 10
//!   },
//!   "debug": true
//! }
//! ```
//! 
//! The macro generates equivalent structs with proper derives and a static instance:
//! 
//! ```rust
//! // Generated by the macro (you don't write this)
//! #[derive(Debug, Clone, Serialize, Deserialize, Default)]
//! pub struct MyAppConfig {
//!     pub server: Server,
//!     pub database: Database,
//!     pub debug: bool,
//! }
//! 
//! #[derive(Debug, Clone, Serialize, Deserialize, Default)]
//! pub struct Server {
//!     pub port: i64,
//!     pub host: String,
//! }
//! 
//! #[derive(Debug, Clone, Serialize, Deserialize, Default)]
//! pub struct Database {
//!     pub url: String,
//!     pub pool_size: i64,
//! }
//! 
//! static MY_APP_CONFIG: LazyLock<MyAppConfig> = LazyLock::new(|| {
//!     Config::<MyAppConfig>::load("myapp")
//!         .map(|config| config.clone_config())
//!         .unwrap_or_else(|e| {
//!             tracing::warn!("Failed to load config myapp: {}, using default", e);
//!             MyAppConfig::default()
//!         })
//! });
//! 
//! impl MyAppConfig {
//!     pub fn global() -> &'static MyAppConfig {
//!         &MY_APP_CONFIG
//!     }
//! }
//! ```
//! 
//! [`superconfig`]: https://docs.rs/superconfig
//! [Typify]: https://docs.rs/typify

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, LitStr, Ident, Token, Result as SynResult};
use syn::parse::{Parse, ParseStream};
use std::fs;
use std::path::{Path, PathBuf};
use heck::{ToSnakeCase, ToShoutySnakeCase};

/// Input for the config! macro: "config_name" => StructName
struct ConfigInput {
    config_name: LitStr,
    _arrow: Token![=>],
    struct_name: Ident,
}

/// Input for the config_builder! macro
/// Supports: config_builder!(StructName [, defaults: fn, env_prefix: "PREFIX", config_file: path, cli_overrides: overrides])
struct ConfigBuilderInput {
    struct_name: Ident,
    options: ConfigOptions,
}

/// Optional configuration parameters
#[derive(Default)]
struct ConfigOptions {
    defaults_fn: Option<syn::Path>,
    env_prefix: Option<LitStr>,
    config_file: Option<syn::Expr>,
    cli_overrides: Option<syn::Expr>,
}

impl Parse for ConfigInput {
    fn parse(input: ParseStream) -> SynResult<Self> {
        Ok(ConfigInput {
            config_name: input.parse()?,
            _arrow: input.parse()?,
            struct_name: input.parse()?,
        })
    }
}

impl Parse for ConfigBuilderInput {
    fn parse(input: ParseStream) -> SynResult<Self> {
        let struct_name: Ident = input.parse()?;
        let mut options = ConfigOptions::default();
        
        // Parse optional parameters
        while !input.is_empty() {
            let _comma: Token![,] = input.parse()?;
            
            if input.is_empty() {
                break;
            }
            
            let option_name: Ident = input.parse()?;
            let _colon: Token![:] = input.parse()?;
            
            match option_name.to_string().as_str() {
                "defaults" => {
                    options.defaults_fn = Some(input.parse()?);
                },
                "env_prefix" => {
                    options.env_prefix = Some(input.parse()?);
                },
                "config_file" => {
                    options.config_file = Some(input.parse()?);
                },
                "cli_overrides" => {
                    options.cli_overrides = Some(input.parse()?);
                },
                _ => {
                    return Err(syn::Error::new_spanned(
                        option_name,
                        "Unknown option. Supported: defaults, env_prefix, config_file, cli_overrides"
                    ));
                }
            }
        }
        
        Ok(ConfigBuilderInput {
            struct_name,
            options,
        })
    }
}

/// Auto-generate configuration struct and LazyLock static from config files using Typify
/// 
/// # Syntax
/// ```rust
/// use superconfig::config;
/// 
/// config!("myapp" => MyAppConfig);
/// ```
/// 
/// # Generated Code
/// - Complete struct hierarchy using Typify
/// - LazyLock static instance for zero-copy access
/// - `::global()` method for convenient access
#[proc_macro]
pub fn config(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ConfigInput);
    let config_name = input.config_name.value();
    let struct_name = &input.struct_name;
    
    // Find config file
    let config_file = match find_config_file(&config_name) {
        Some(path) => path,
        None => {
            return syn::Error::new_spanned(
                &input.config_name,
                format!("No config file found for '{config_name}'. Expected: {config_name}.json, {config_name}.yaml, or {config_name}.yml")
            ).to_compile_error().into();
        }
    };
    
    // Generate struct definitions using Typify
    let struct_definitions = match generate_structs_with_typify(&config_file, struct_name) {
        Ok(definitions) => definitions,
        Err(e) => {
            return syn::Error::new_spanned(
                &input.struct_name,
                format!("Failed to generate structs from config file {}: {}", config_file.display(), e)
            ).to_compile_error().into();
        }
    };
    
    // Generate LazyLock static instance
    let static_name = struct_name.to_string().to_shouty_snake_case();
    let static_ident = syn::Ident::new(&static_name, struct_name.span());
    
    let expanded = quote! {
        #struct_definitions
        
        /// Auto-generated LazyLock static instance for zero-copy configuration access
        pub static #static_ident: ::std::sync::LazyLock<#struct_name> = ::std::sync::LazyLock::new(|| {
            ::superconfig::Config::<#struct_name>::load(#config_name)
                .map(|config| config.clone_config())
                .unwrap_or_else(|e| {
                    ::tracing::warn!("Failed to load config {}: {}, using default", #config_name, e);
                    #struct_name::default()
                })
        });
        
        impl #struct_name {
            /// Get reference to the global configuration instance
            pub fn global() -> &'static #struct_name {
                &#static_ident
            }
        }
    };
    
    TokenStream::from(expanded)
}

/// Create LazyLock static for existing configuration structs with auto-derived settings
/// 
/// # Syntax
/// ```rust
/// use superconfig::config_builder;
/// 
/// // Basic usage with auto-derivation
/// config_builder!(GuardyConfig);
/// // Auto-derives: env_prefix: "GUARDY", config_name: "guardy"
/// 
/// // With overrides
/// config_builder!(GuardyConfig, 
///     env_prefix: "CUSTOM_PREFIX",
///     config_file: "custom-config.yaml",
///     cli_overrides: cli_args
/// );
/// ```
/// 
/// # Generated Code
/// - LazyLock static instance using ConfigBuilder
/// - `::global()` method for convenient access
/// - Auto-derived env_prefix and config_name from struct name
/// - Flexible defaults handling (Default trait optional)
#[proc_macro]
pub fn config_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ConfigBuilderInput);
    let struct_name = &input.struct_name;
    let options = &input.options;
    
    // Auto-derive values from struct name
    let (auto_env_prefix, auto_config_name) = derive_config_values(&struct_name.to_string());
    
    // Use provided values or auto-derived ones
    let env_prefix = options.env_prefix.as_ref()
        .map(|s| s.value())
        .unwrap_or(auto_env_prefix);
        
    let config_name = extract_config_name_from_options(options)
        .unwrap_or(auto_config_name);
    
    // Generate LazyLock static instance
    let static_name = struct_name.to_string().to_shouty_snake_case();
    let static_ident = syn::Ident::new(&static_name, struct_name.span());
    
    // Build ConfigBuilder calls
    let defaults_call = if let Some(defaults_fn) = &options.defaults_fn {
        quote! { .with_defaults(#defaults_fn()) }
    } else {
        // Use Default trait (now required)
        quote! { .with_defaults(#struct_name::default()) }
    };
    
    let env_prefix_call = quote! { .with_env_prefix(#env_prefix) };
    
    let config_file_call = if let Some(config_file) = &options.config_file {
        quote! { .with_config_file(Some(#config_file)) }
    } else {
        quote! { .with_config_file(Some(#config_name)) }
    };
    
    let cli_overrides_call = if let Some(cli_overrides) = &options.cli_overrides {
        quote! { .with_cli_overrides(#cli_overrides) }
    } else {
        quote! {}
    };
    
    let expanded = quote! {
        /// Auto-generated LazyLock static instance for existing struct
        pub static #static_ident: ::std::sync::LazyLock<#struct_name> = ::std::sync::LazyLock::new(|| {
            ::superconfig::ConfigBuilder::<#struct_name>::new()
                #defaults_call
                #env_prefix_call
                #config_file_call
                #cli_overrides_call
                .build()
                .unwrap_or_else(|e| {
                    ::tracing::error!("Failed to build config: {}", e);
                    panic!("Configuration failed to load and no fallback available")
                })
        });
        
        impl #struct_name {
            /// Get reference to the global configuration instance
            pub fn global() -> &'static #struct_name {
                &#static_ident
            }
        }
    };
    
    TokenStream::from(expanded)
}

/// Generate struct definitions using Typify from config file
fn generate_structs_with_typify(
    config_path: &Path,
    struct_name: &Ident,
) -> Result<proc_macro2::TokenStream, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(config_path)?;
    
    // Convert config file to JSON for Typify
    let config_json: serde_json::Value = match config_path.extension().and_then(|ext| ext.to_str()) {
        Some("json") => serde_json::from_str(&content)?,
        Some("yaml") | Some("yml") => {
            let yaml_value: serde_yaml_bw::Value = serde_yaml_bw::from_str(&content)?;
            serde_json::to_value(yaml_value)?
        },
        _ => return Err("Unsupported file extension".into()),
    };
    
    // Generate JSON Schema with proper title for naming
    let schema = generate_json_schema_from_config(&config_json, &struct_name.to_string());
    
    // Convert to RootSchema that Typify expects
    let root_schema: schemars::schema::RootSchema = serde_json::from_value(schema)
        .map_err(|e| format!("Failed to convert to RootSchema: {e}"))?;
    
    // Use Typify to generate Rust structs with settings to avoid conflicts
    let settings = typify::TypeSpaceSettings::default();
    let mut typespace = typify::TypeSpace::new(&settings);
    typespace.add_root_schema(root_schema)?;
    
    // Get the generated code as TokenStream
    let generated_tokens = typespace.to_stream();
    
    // Parse the generated tokens to modify them
    let generated_string = generated_tokens.to_string();
    
    // Fix error module conflicts and add Default derives
    let fixed_code = fix_typify_output(&generated_string, struct_name);
    
    // Parse back to TokenStream
    let tokens: proc_macro2::TokenStream = fixed_code.parse()
        .map_err(|e| format!("Failed to parse generated code: {e}"))?;
    
    Ok(tokens)
}

/// Generate JSON Schema from configuration data
fn generate_json_schema_from_config(config: &serde_json::Value, struct_name: &str) -> serde_json::Value {
    match config {
        serde_json::Value::Object(map) => {
            let mut properties_obj = serde_json::Map::new();
            let mut required_fields = Vec::new();
            
            for (key, value) in map {
                properties_obj.insert(key.clone(), infer_schema_from_value(value));
                // Mark all fields as required (since they exist in the config)
                required_fields.push(key.clone());
            }
            
            serde_json::json!({
                "type": "object",
                "properties": properties_obj,
                "required": required_fields,  // Make fields required to avoid Option<T>
                "additionalProperties": false,
                "$schema": "http://json-schema.org/draft-07/schema#",
                "title": struct_name
            })
        },
        _ => {
            // For non-object root values, wrap in an object
            serde_json::json!({
                "type": "object",
                "properties": {
                    "value": infer_schema_from_value(config)
                },
                "required": ["value"],
                "additionalProperties": false,
                "$schema": "http://json-schema.org/draft-07/schema#",
                "title": struct_name
            })
        }
    }
}

/// Infer JSON Schema from a value
fn infer_schema_from_value(value: &serde_json::Value) -> serde_json::Value {
    match value {
        serde_json::Value::String(_) => serde_json::json!({
            "type": "string"
        }),
        serde_json::Value::Number(n) => {
            if n.is_i64() {
                serde_json::json!({ "type": "integer" })
            } else {
                serde_json::json!({ "type": "number" })
            }
        },
        serde_json::Value::Bool(_) => serde_json::json!({
            "type": "boolean"
        }),
        serde_json::Value::Array(arr) => {
            let item_schema = if let Some(first_item) = arr.first() {
                infer_schema_from_value(first_item)
            } else {
                serde_json::json!({ "type": "string" })
            };
            
            serde_json::json!({
                "type": "array",
                "items": item_schema
            })
        },
        serde_json::Value::Object(map) => {
            let mut properties_obj = serde_json::Map::new();
            let mut required_fields = Vec::new();
            
            for (key, nested_value) in map {
                properties_obj.insert(key.clone(), infer_schema_from_value(nested_value));
                required_fields.push(key.clone());
            }
            
            serde_json::json!({
                "type": "object",
                "properties": properties_obj,
                "required": required_fields,
                "additionalProperties": false
            })
        },
        serde_json::Value::Null => serde_json::json!({
            "type": "null"
        })
    }
}

/// Fix Typify output to avoid conflicts and use proper struct names
fn fix_typify_output(generated_code: &str, struct_name: &Ident) -> String {
    let mut result = generated_code.to_string();
    let struct_name_str = struct_name.to_string();
    
    // 1. Struct name should already be correct from the title field in JSON Schema
    // Typify generates based on the "title" field, which we set to struct_name
    
    // 2. Fix error module conflicts by making error module unique per struct
    let error_module_name = format!("{}_error", struct_name_str.to_lowercase());
    
    // The actual format in TokenStream has newline after "pub mod error"
    result = result.replace("pub mod error\n{", &format!("pub mod {error_module_name}\n{{"));
    result = result.replace("pub mod error\r\n{", &format!("pub mod {error_module_name}\r\n{{"));
    result = result.replace("pub mod error {", &format!("pub mod {error_module_name} {{"));
    // Also handle the case where there's no space/newline
    result = result.replace("pub mod error{", &format!("pub mod {error_module_name}{{"));
    result = result.replace("error::", &format!("{error_module_name}::"));
    
    // 3. Add Default derive to all structs
    // The actual format in the proc macro pipeline is different from the debug output
    let derive_pattern = "#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]";
    let enhanced_derive = "#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, Default)]";
    
    // Replace the derive pattern to add Default
    if result.contains(derive_pattern) {
        result = result.replace(derive_pattern, enhanced_derive);
    }
    
    result
}

/// Find config file for the given name in standard locations
fn find_config_file(config_name: &str) -> Option<PathBuf> {
    let search_paths = vec![
        // Current directory (highest priority)
        format!("{}.json", config_name),
        format!("{}.yaml", config_name),
        format!("{}.yml", config_name),
        
        // Tests directory (for integration tests)
        format!("tests/{}.json", config_name),
        format!("tests/{}.yaml", config_name),
        format!("tests/{}.yml", config_name),
        
        // Tests configs subdirectory (organized configs)
        format!("tests/configs/{}.json", config_name),
        format!("tests/configs/{}.yaml", config_name),
        format!("tests/configs/{}.yml", config_name),
        
        // Package-relative tests directory (when running from workspace root)
        format!("packages/superconfig/tests/{}.json", config_name),
        format!("packages/superconfig/tests/{}.yaml", config_name),
        format!("packages/superconfig/tests/{}.yml", config_name),
        
        // Package-relative tests configs subdirectory
        format!("packages/superconfig/tests/configs/{}.json", config_name),
        format!("packages/superconfig/tests/configs/{}.yaml", config_name),
        format!("packages/superconfig/tests/configs/{}.yml", config_name),
        
        // .config subdirectory
        format!(".config/{}/config.json", config_name),
        format!(".config/{}/config.yaml", config_name),
        format!(".config/{}/config.yml", config_name),
    ];
    
    for path_str in search_paths {
        let path = PathBuf::from(&path_str);
        if path.exists() {
            return Some(path);
        }
    }
    
    // Try git repository root if available
    if let Ok(output) = std::process::Command::new("git")
        .args(["rev-parse", "--show-toplevel"])
        .output()
        && output.status.success() {
            let git_root_string = String::from_utf8_lossy(&output.stdout);
            let git_root = git_root_string.trim();
            let git_root_path = PathBuf::from(git_root);
            
            let git_paths = vec![
                git_root_path.join(format!("{config_name}.json")),
                git_root_path.join(format!("{config_name}.yaml")),
                git_root_path.join(format!("{config_name}.yml")),
            ];
            
            for path in git_paths {
                if path.exists() {
                    return Some(path);
                }
            }
        }
    
    None
}


/// Auto-derive env_prefix and config_name from struct name
/// 
/// Examples:
/// - GuardyConfig -> ("GUARDY", "guardy")
/// - MyAppConfig -> ("MY_APP", "myapp")
/// - DatabaseConfig -> ("DATABASE", "database")
fn derive_config_values(struct_name: &str) -> (String, String) {
    // Remove "Config" suffix if present
    let base_name = if struct_name.ends_with("Config") {
        &struct_name[..struct_name.len() - 6]
    } else {
        struct_name
    };
    
    // Convert to env_prefix (SHOUTY_SNAKE_CASE)
    let env_prefix = base_name.to_shouty_snake_case();
    
    // Convert to config_name (snake_case, then lowercase for file names)
    let config_name = base_name.to_snake_case().to_lowercase();
    
    (env_prefix, config_name)
}

/// Extract config name from options if config_file is provided
fn extract_config_name_from_options(options: &ConfigOptions) -> Option<String> {
    if let Some(config_file_expr) = &options.config_file {
        // Try to extract string literal from expression
        if let syn::Expr::Lit(syn::ExprLit { 
            lit: syn::Lit::Str(lit_str), .. 
        }) = config_file_expr {
            let path = lit_str.value();
            // Extract base name without extension
            if let Some(file_name) = std::path::Path::new(&path).file_stem() {
                if let Some(name_str) = file_name.to_str() {
                    return Some(name_str.to_string());
                }
            }
        }
    }
    None
}